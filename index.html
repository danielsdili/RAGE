<!DOCTYPE html>
<html lang="cs">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
  <title>ROADSTER BRAWL 1.1 - Night Edition</title>

  <style>
    body{
      margin:0;
      background: radial-gradient(circle at top, #111, #000);
      font-family: Arial, sans-serif;
      overflow:hidden;
      color:white;
      touch-action:none;
    }

    #hud{
      width:100%;
      max-width:420px;
      margin:0 auto;
      display:flex;
      justify-content:space-between;
      font-size:13px;
      font-weight:bold;
      padding:10px 14px;
      box-sizing:border-box;
      opacity:0.95;
      gap:10px;
      align-items:center;
    }

    #hudLeft, #hudRight{
      display:flex;
      flex-direction:column;
      gap:6px;
    }

    #hpWrap{
      width:140px;
      height:12px;
      border:2px solid gold;
      border-radius:8px;
      overflow:hidden;
      background:rgba(0,0,0,0.6);
      box-shadow:0 0 10px rgba(255,215,0,0.2);
    }

    #hpBar{
      height:100%;
      width:100%;
      background: linear-gradient(90deg, #ff3333, #ffcc00, #00ff66);
      transition: width 0.08s linear;
    }

    #wrap{
      width:100%;
      max-width:420px;
      margin:0 auto;
      position:relative;
    }

    canvas{
      width:100%;
      height:75vh;
      border:4px solid #444;
      border-radius:14px;
      background: linear-gradient(#1a1a1a, #0b0b0b);
      display:block;
      box-shadow:0 0 20px rgba(255,255,255,0.08);
      transform-origin:center;
      transition: transform 0.15s ease;
    }

    canvas.hitShake{
      transform: scale(1.03);
    }

    #controls{
      width:100%;
      max-width:420px;
      margin:12px auto;
      display:flex;
      justify-content:space-between;
      gap:10px;
      padding:0 12px;
      box-sizing:border-box;
    }

    .btn{
      flex:1;
      height:78px;
      border-radius:18px;
      color:black;
      font-size:26px;
      font-weight:900;
      display:flex;
      justify-content:center;
      align-items:center;
      user-select:none;
      -webkit-user-select:none;
      -webkit-touch-callout:none;
      background: repeating-linear-gradient(
        45deg,
        #ffd500,
        #ffd500 12px,
        #111 12px,
        #111 24px
      );
      border:3px solid #ffd500;
      box-shadow:0 0 14px rgba(255,213,0,0.25);
      text-shadow:0 0 6px rgba(0,0,0,0.8);
    }

    .btn:active{
      transform:scale(0.96);
      filter:brightness(1.2);
    }

    #controlsLeft{
      flex:1.1;
      display:flex;
      gap:10px;
    }

    #controlsRight{
      flex:1.4;
      display:flex;
      gap:10px;
      justify-content:flex-end;
    }

    .smallBtn{
      font-size:28px;
    }

    /* START SCREEN */
    #startScreen{
      position:absolute;
      inset:0;
      background:rgba(0,0,0,0.95);
      display:flex;
      justify-content:center;
      align-items:center;
      flex-direction:column;
      text-align:center;
      z-index:999;
      border-radius:14px;
      overflow:hidden;
    }

    #introText{
      font-size:16px;
      font-weight:900;
      letter-spacing:3px;
      color:#ffd500;
      opacity:0;
      transform:translateY(20px);
      animation:introFade 1.5s ease forwards;
    }

    #mainLogo{
      font-size:52px;
      margin:12px 0 0 0;
      color:gold;
      letter-spacing:8px;
      text-shadow:0 0 25px rgba(255,215,0,0.35);
      opacity:0;
      transform:scale(0.8);
      animation:logoPop 1.8s ease forwards;
      animation-delay:1.2s;
    }

    #subText{
      margin-top:10px;
      font-size:14px;
      opacity:0;
      animation:subFade 1.4s ease forwards;
      animation-delay:2.5s;
    }

    #startBtn{
      margin-top:26px;
      padding:16px 32px;
      border:none;
      border-radius:14px;
      font-size:20px;
      cursor:pointer;
      background: repeating-linear-gradient(
        45deg,
        #ffd500,
        #ffd500 12px,
        #111 12px,
        #111 24px
      );
      color:black;
      font-weight:900;
      box-shadow:0 0 20px rgba(255,215,0,0.25);
      opacity:0;
      pointer-events:none;
      animation:btnShow 1.2s ease forwards;
      animation-delay:3.6s;
    }

    @keyframes introFade{
      0%{opacity:0; transform:translateY(20px);}
      100%{opacity:1; transform:translateY(0px);}
    }
    @keyframes logoPop{
      0%{opacity:0; transform:scale(0.75);}
      60%{opacity:1; transform:scale(1.08);}
      100%{opacity:1; transform:scale(1);}
    }
    @keyframes subFade{
      0%{opacity:0;}
      100%{opacity:0.85;}
    }
    @keyframes btnShow{
      0%{opacity:0; transform:translateY(15px);}
      100%{opacity:1; transform:translateY(0px); pointer-events:auto;}
    }

    /* GAME OVER */
    #gameOver{
      position:absolute;
      inset:0;
      background:rgba(0,0,0,0.88);
      display:none;
      justify-content:center;
      align-items:center;
      flex-direction:column;
      text-align:center;
      z-index:999;
      border-radius:14px;
    }

    #gameOver h1{
      margin:0;
      font-size:38px;
      color:gold;
      text-shadow:0 0 15px rgba(255,215,0,0.3);
    }

    #gameOver p{
      margin:12px 0;
      opacity:0.9;
    }

    button{
      padding:12px 18px;
      border:none;
      border-radius:10px;
      font-size:16px;
      cursor:pointer;
      background:gold;
      font-weight:bold;
      box-shadow:0 0 10px rgba(255,215,0,0.3);
    }
  </style>
</head>

<body>

<div id="hud">
  <div id="hudLeft">
    <div>Sk√≥re: <span id="score">0</span></div>
    <div>Vlna: <span id="wave">1</span></div>
  </div>

  <div id="hudRight">
    <div>HP: <span id="hpText">100</span></div>
    <div id="hpWrap"><div id="hpBar"></div></div>
  </div>
</div>

<div id="wrap">
  <canvas id="game"></canvas>

  <div id="startScreen">
    <div id="introText">DANIEL_SDILI UV√ÅD√ç:</div>
    <div id="mainLogo">ROADSTER</div>
    <div id="subText">Brawl Night Edition</div>
    <button id="startBtn">START</button>
  </div>

  <div id="gameOver">
    <h1>GAME OVER</h1>
    <p>Tvoje sk√≥re: <span id="finalScore">0</span></p>
    <button onclick="restartGame()">Zkusit znovu</button>
  </div>
</div>

<div id="controls">
  <div id="controlsLeft">
    <div class="btn smallBtn" id="leftBtn">‚óÄ</div>
    <div class="btn smallBtn" id="rightBtn">‚ñ∂</div>
  </div>

  <div id="controlsRight">
    <div class="btn" id="kickBtn">ü¶µ KOP</div>
    <div class="btn" id="batBtn">üèè P√ÅLKA</div>
  </div>
</div>

<script>
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  const scoreEl = document.getElementById("score");
  const waveEl = document.getElementById("wave");
  const hpText = document.getElementById("hpText");
  const hpBar = document.getElementById("hpBar");

  const gameOverScreen = document.getElementById("gameOver");
  const finalScoreEl = document.getElementById("finalScore");

  const startScreen = document.getElementById("startScreen");
  const startBtn = document.getElementById("startBtn");

  const leftBtn = document.getElementById("leftBtn");
  const rightBtn = document.getElementById("rightBtn");
  const kickBtn = document.getElementById("kickBtn");
  const batBtn = document.getElementById("batBtn");

  let w = 0, h = 0;

  function resizeCanvas(){
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width * devicePixelRatio;
    canvas.height = rect.height * devicePixelRatio;
    ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
    w = rect.width;
    h = rect.height;
  }

  window.addEventListener("resize", resizeCanvas);
  resizeCanvas();

  function rand(min, max){ return Math.random() * (max - min) + min; }

  let running = false;
  let frame = 0;

  let score = 0;
  let wave = 1;

  let bgScroll = 0;

  let holdingLeft = false;
  let holdingRight = false;

  let camShake = 0;

  function floorY(){
    return h - 135;
  }

  const player = {
    x: 120,
    y: 0,
    w: 58,
    h: 118,
    hp: 100,
    maxHp: 100,
    facing: 1,
    hurtTimer: 0,

    attackTimer: 0,
    attackType: null,
    batSwing: 0
  };

  let enemies = [];
  let blood = [];
  let textPop = [];

  function spawnEnemy(){
    const fromLeft = Math.random() < 0.5;
    const x = fromLeft ? -80 : w + 80;

    enemies.push({
      x,
      y: floorY(),
      w: 56,
      h: 114,
      hp: 50 + wave * 8,
      maxHp: 50 + wave * 8,
      dir: fromLeft ? 1 : -1,
      speed: 1.2 + wave * 0.08,
      hitTimer: 0,
      alive: true,
      type: ["hoodie","cap","jacket"][Math.floor(Math.random()*3)]
    });
  }

  function spawnWave(){
    const count = 2 + Math.min(8, wave);
    for(let i=0;i<count;i++){
      setTimeout(() => {
        if(running) spawnEnemy();
      }, i * 500);
    }
  }

  function splashBlood(x, y, big){
    const amount = big ? 80 : 22;

    for(let i=0;i<amount;i++){
      blood.push({
        x: x + rand(-12, 12),
        y: y + rand(-25, 15),
        vx: rand(-10, 10) * (big ? 1.25 : 0.6),
        vy: rand(-18, -4) * (big ? 1.4 : 0.7),
        life: rand(50, 95) * (big ? 1.2 : 1),
        size: rand(big ? 6 : 3, big ? 20 : 10),
        drip: rand(0.2, 0.55),
        alpha: rand(0.7, 1)
      });
    }
  }

  function addComicText(x, y, txt){
    textPop.push({ x, y, txt, life: 70, vy: -0.6 });
  }

  function updateBlood(){
    for(let i=blood.length-1;i>=0;i--){
      const b = blood[i];
      b.life--;
      b.x += b.vx;
      b.y += b.vy;
      b.vy += b.drip;
      b.vx *= 0.96;
      if(b.life <= 0) blood.splice(i, 1);
    }
  }

  function drawBlood(){
    blood.forEach(b => {
      ctx.save();
      ctx.globalAlpha = Math.max(0, b.life / 95) * b.alpha;

      const g = ctx.createRadialGradient(b.x, b.y, 2, b.x, b.y, b.size);
      g.addColorStop(0, "rgba(255,0,0,1)");
      g.addColorStop(0.4, "rgba(200,0,0,0.95)");
      g.addColorStop(1, "rgba(120,0,0,0)");

      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.size, 0, Math.PI*2);
      ctx.fill();

      ctx.restore();
    });
  }

  function updateTextPop(){
    for(let i=textPop.length-1;i>=0;i--){
      const t = textPop[i];
      t.life--;
      t.y += t.vy;
      if(t.life <= 0) textPop.splice(i, 1);
    }
  }

  function drawTextPop(){
    textPop.forEach(t => {
      ctx.save();
      ctx.globalAlpha = Math.max(0, t.life / 70);

      ctx.font = "900 28px Arial";
      ctx.textAlign = "center";
      ctx.fillStyle = "gold";
      ctx.strokeStyle = "black";
      ctx.lineWidth = 6;

      ctx.strokeText(t.txt, t.x, t.y);
      ctx.fillText(t.txt, t.x, t.y);

      ctx.restore();
    });
  }

  function drawStreet(){
    bgScroll += 1.2;

    const roadGrad = ctx.createLinearGradient(0, 0, 0, h);
    roadGrad.addColorStop(0, "#0b0b0f");
    roadGrad.addColorStop(0.6, "#050508");
    roadGrad.addColorStop(1, "#000000");

    ctx.fillStyle = roadGrad;
    ctx.fillRect(0, 0, w, h);

    // neon borders
    ctx.globalAlpha = 0.35;
    ctx.fillStyle = "rgba(255,215,0,0.9)";
    ctx.fillRect(0, 0, 10, h);
    ctx.fillRect(w - 10, 0, 10, h);
    ctx.globalAlpha = 1;

    // scrolling lines
    ctx.globalAlpha = 0.15;
    ctx.fillStyle = "rgba(255,255,255,0.7)";
    for(let i=0;i<10;i++){
      const y = ((i * 90) + bgScroll) % (h + 120) - 120;
      ctx.fillRect(w/2 - 70, y, 140, 10);
    }
    ctx.globalAlpha = 1;

    // floor line
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = "rgba(255,255,255,0.6)";
    ctx.fillRect(0, floorY() + player.h - 10, w, 2);
    ctx.globalAlpha = 1;

    // grain
    ctx.globalAlpha = 0.10;
    for(let i=0;i<160;i++){
      ctx.fillStyle = (Math.random() > 0.5)
        ? "rgba(255,255,255,0.18)"
        : "rgba(0,0,0,0.35)";
      ctx.fillRect(rand(0,w), rand(0,h), 1, 1);
    }
    ctx.globalAlpha = 1;
  }

  function drawRockstarFighter(x, y, ww, hh, facing, type, hurt, isEnemy){
    ctx.save();
    ctx.translate(x + ww/2, y + hh/2);
    ctx.scale(facing, 1);

    // shadow
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = "black";
    ctx.beginPath();
    ctx.ellipse(0, hh/2 - 12, ww * 0.55, 16, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    let jacketColor = isEnemy ? "#2a1a1a" : "#111111";
    if(type === "hoodie") jacketColor = "#1a1a2a";
    if(type === "cap") jacketColor = "#222222";
    if(type === "jacket") jacketColor = "#2a1a1a";

    // legs
    ctx.fillStyle = "rgba(10,10,10,0.95)";
    ctx.fillRect(-ww*0.22, hh*0.05, ww*0.18, hh*0.38);
    ctx.fillRect(ww*0.04, hh*0.05, ww*0.18, hh*0.38);

    // shoes
    ctx.fillStyle = "rgba(40,40,40,0.95)";
    ctx.fillRect(-ww*0.24, hh*0.40, ww*0.22, hh*0.08);
    ctx.fillRect(ww*0.02, hh*0.40, ww*0.22, hh*0.08);

    // torso
    const torsoGrad = ctx.createLinearGradient(0, -hh*0.3, 0, hh*0.3);
    torsoGrad.addColorStop(0, jacketColor);
    torsoGrad.addColorStop(1, "#0a0a0a");

    ctx.fillStyle = torsoGrad;
    ctx.beginPath();
    ctx.moveTo(-ww*0.30, -hh*0.20);
    ctx.lineTo(ww*0.30, -hh*0.20);
    ctx.lineTo(ww*0.22, hh*0.22);
    ctx.lineTo(-ww*0.22, hh*0.22);
    ctx.closePath();
    ctx.fill();

    // shoulders
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = jacketColor;
    ctx.fillRect(-ww*0.35, -hh*0.18, ww*0.70, hh*0.14);
    ctx.globalAlpha = 1;

    // arms
    ctx.fillStyle = "rgba(15,15,15,0.95)";
    ctx.fillRect(-ww*0.42, -hh*0.12, ww*0.14, hh*0.32);
    ctx.fillRect(ww*0.28, -hh*0.12, ww*0.14, hh*0.32);

    // hands
    ctx.fillStyle = "rgba(60,50,40,0.9)";
    ctx.fillRect(-ww*0.43, hh*0.17, ww*0.16, hh*0.10);
    ctx.fillRect(ww*0.27, hh*0.17, ww*0.16, hh*0.10);

    // head
    ctx.fillStyle = "rgba(70,60,50,0.92)";
    ctx.beginPath();
    ctx.arc(0, -hh*0.30, ww*0.18, 0, Math.PI*2);
    ctx.fill();

    // cap/hood
    if(type === "cap"){
      ctx.fillStyle = "rgba(20,20,20,0.95)";
      ctx.fillRect(-ww*0.18, -hh*0.42, ww*0.36, hh*0.10);
      ctx.fillRect(ww*0.04, -hh*0.38, ww*0.22, hh*0.05);
    }

    if(type === "hoodie"){
      ctx.globalAlpha = 0.9;
      ctx.fillStyle = "rgba(15,15,15,0.95)";
      ctx.beginPath();
      ctx.arc(0, -hh*0.30, ww*0.24, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    // eyes
    ctx.fillStyle = "rgba(0,0,0,0.85)";
    ctx.fillRect(-ww*0.10, -hh*0.33, ww*0.08, hh*0.03);
    ctx.fillRect(ww*0.02, -hh*0.33, ww*0.08, hh*0.03);

    // hurt flash
    if(hurt > 0){
      ctx.globalAlpha = 0.3;
      ctx.fillStyle = "rgba(255,0,0,0.8)";
      ctx.fillRect(-ww*0.45, -hh*0.48, ww*0.90, hh*0.95);
      ctx.globalAlpha = 1;
    }

    ctx.restore();
  }

  function drawBatSwing(px, py, facing, progress){
    const swingAngle = (-1.2 + progress * 2.2) * facing;

    ctx.save();
    ctx.translate(px, py);
    ctx.rotate(swingAngle);

    ctx.globalAlpha = 0.95;
    ctx.fillStyle = "#b88940";
    ctx.fillRect(0, -8, 70, 16);

    ctx.fillStyle = "#e0b060";
    ctx.fillRect(55, -10, 20, 20);

    ctx.globalAlpha = 0.22;
    ctx.fillStyle = "rgba(255,255,255,0.8)";
    ctx.fillRect(10, -22, 60, 6);
    ctx.fillRect(10, 16, 60, 6);

    ctx.restore();
    ctx.globalAlpha = 1;
  }

  function updatePlayer(){
    player.y = floorY();

    if(player.hurtTimer > 0) player.hurtTimer--;

    if(player.attackTimer > 0){
      player.attackTimer--;
      if(player.attackType === "bat") player.batSwing += 0.08;

      if(player.attackTimer <= 0){
        player.attackType = null;
        player.batSwing = 0;
      }
      return;
    }

    if(holdingLeft){
      player.x -= 5;
      player.facing = -1;
    }

    if(holdingRight){
      player.x += 5;
      player.facing = 1;
    }

    if(player.x < 20) player.x = 20;
    if(player.x > w - player.w - 20) player.x = w - player.w - 20;
  }

  function rectsOverlap(a, b){
    return !(
      a.x > b.x + b.w ||
      a.x + a.w < b.x ||
      a.y > b.y + b.h ||
      a.y + a.h < b.y
    );
  }

  function doKick(){
    if(!running) return;
    if(player.attackTimer > 0) return;

    player.attackType = "kick";
    player.attackTimer = 18;

    const hitBox = {
      x: player.facing === 1 ? player.x + player.w - 5 : player.x - 45,
      y: player.y + 30,
      w: 55,
      h: 55
    };

    enemies.forEach(e => {
      if(!e.alive) return;

      if(rectsOverlap(hitBox, {x:e.x, y:e.y, w:e.w, h:e.h})){
        e.hp -= 18;
        e.hitTimer = 10;

        score += 10;
        scoreEl.textContent = score;

        splashBlood(e.x + e.w/2, e.y + 55, false);
        camShake = 6;

        if(e.hp <= 0){
          e.alive = false;
          score += 60;
          scoreEl.textContent = score;
          splashBlood(e.x + e.w/2, e.y + 55, false);
        }
      }
    });
  }

  function doBat(){
    if(!running) return;
    if(player.attackTimer > 0) return;

    player.attackType = "bat";
    player.attackTimer = 28;
    player.batSwing = 0;

    const hitBox = {
      x: player.facing === 1 ? player.x + player.w - 10 : player.x - 90,
      y: player.y + 15,
      w: 100,
      h: 85
    };

    enemies.forEach(e => {
      if(!e.alive) return;

      if(rectsOverlap(hitBox, {x:e.x, y:e.y, w:e.w, h:e.h})){
        e.hp -= 38;
        e.hitTimer = 14;

        score += 20;
        scoreEl.textContent = score;

        splashBlood(e.x + e.w/2, e.y + 50, false);
        camShake = 12;

        if(e.hp <= 0){
          e.alive = false;
          score += 120;
          scoreEl.textContent = score;

          splashBlood(e.x + e.w/2, e.y + 50, true);
          addComicText(e.x + e.w/2, e.y - 10, "SPLAT!");
          camShake = 22;

          canvas.classList.add("hitShake");
          setTimeout(() => canvas.classList.remove("hitShake"), 250);
        }
      }
    });
  }

  function enemyAI(){
    enemies.forEach(e => {
      if(!e.alive) return;

      if(e.hitTimer > 0) e.hitTimer--;

      const dx = player.x - e.x;
      const dist = Math.abs(dx);

      e.dir = dx > 0 ? 1 : -1;

      if(dist > 42){
        e.x += e.speed * e.dir;
      } else {
        if(frame % 45 === 0 && player.hurtTimer <= 0){
          player.hp -= 8 + wave * 0.6;
          player.hurtTimer = 18;

          camShake = 10;
          splashBlood(player.x + player.w/2, player.y + player.h/2, false);

          canvas.classList.add("hitShake");
          setTimeout(() => canvas.classList.remove("hitShake"), 160);

          if(player.hp <= 0){
            player.hp = 0;
            endGame();
          }
        }
      }
    });
  }

  function updateEnemies(){
    for(let i=enemies.length-1;i>=0;i--){
      const e = enemies[i];

      if(!e.alive){
        e.y += 2.8;
        if(e.y > h + 200) enemies.splice(i, 1);
      }
    }
  }

  function drawEnemies(){
    enemies.forEach(e => {
      drawRockstarFighter(e.x, e.y, e.w, e.h, e.dir, e.type, e.hitTimer, true);

      ctx.save();
      ctx.globalAlpha = 0.7;
      ctx.fillStyle = "rgba(0,0,0,0.6)";
      ctx.fillRect(e.x, e.y - 12, e.w, 6);

      const pct = Math.max(0, e.hp / e.maxHp);
      ctx.fillStyle = "rgba(255,60,60,0.9)";
      ctx.fillRect(e.x, e.y - 12, e.w * pct, 6);
      ctx.restore();
    });
  }

  function drawPlayer(){
    drawRockstarFighter(player.x, player.y, player.w, player.h, player.facing, "jacket", player.hurtTimer, false);

    if(player.attackType === "kick"){
      ctx.save();
      ctx.globalAlpha = 0.95;
      ctx.fillStyle = "rgba(20,20,20,0.95)";

      const lx = player.facing === 1 ? player.x + player.w - 5 : player.x - 30;
      const ly = player.y + 65;

      ctx.fillRect(lx, ly, 35 * player.facing, 12);

      ctx.globalAlpha = 0.25;
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.fillRect(lx, ly - 10, 40 * player.facing, 5);
      ctx.restore();
    }

    if(player.attackType === "bat"){
      const px = player.x + player.w/2;
      const py = player.y + 60;
      drawBatSwing(px, py, player.facing, Math.min(1, player.batSwing));
    }
  }

  function drawVignette(){
    const g = ctx.createRadialGradient(w/2, h/2, 80, w/2, h/2, Math.max(w,h));
    g.addColorStop(0, "rgba(0,0,0,0)");
    g.addColorStop(0.65, "rgba(0,0,0,0.08)");
    g.addColorStop(1, "rgba(0,0,0,0.75)");

    ctx.fillStyle = g;
    ctx.fillRect(0, 0, w, h);
  }

  function updateHUD(){
    hpText.textContent = Math.floor(player.hp);
    const pct = Math.max(0, player.hp / player.maxHp);
    hpBar.style.width = (pct * 100) + "%";
  }

  function endGame(){
    running = false;
    finalScoreEl.textContent = score;
    gameOverScreen.style.display = "flex";
  }

  function restartGame(){
    score = 0;
    wave = 1;
    frame = 0;

    enemies = [];
    blood = [];
    textPop = [];

    player.hp = 100;
    player.x = w/2 - player.w/2;
    player.attackTimer = 0;
    player.attackType = null;
    player.hurtTimer = 0;
    player.batSwing = 0;

    scoreEl.textContent = score;
    waveEl.textContent = wave;
    hpBar.style.width = "100%";

    gameOverScreen.style.display = "none";
    running = true;

    spawnWave();
  }

  window.restartGame = restartGame;

  function checkWave(){
    const aliveCount = enemies.filter(e => e.alive).length;
    if(aliveCount === 0 && running){
      wave++;
      waveEl.textContent = wave;
      spawnWave();
    }
  }

  function loop(){
    frame++;

    if(running){
      updatePlayer();
      enemyAI();
      updateEnemies();
      updateBlood();
      updateTextPop();
      updateHUD();
      checkWave();
    }

    ctx.save();

    if(camShake > 0){
      ctx.translate(rand(-camShake, camShake), rand(-camShake, camShake));
      camShake *= 0.88;
    }

    drawStreet();
    drawBlood();
    drawEnemies();
    drawPlayer();
    drawTextPop();

    ctx.restore();

    drawVignette();

    requestAnimationFrame(loop);
  }

  // BUTTON EVENTS (touch + mouse)
  function bindHold(btn, onDown, onUp){
    btn.addEventListener("touchstart", (e)=>{ e.preventDefault(); onDown(); });
    btn.addEventListener("touchend", (e)=>{ e.preventDefault(); onUp(); });
    btn.addEventListener("mousedown", (e)=>{ e.preventDefault(); onDown(); });
    btn.addEventListener("mouseup", (e)=>{ e.preventDefault(); onUp(); });
    btn.addEventListener("mouseleave", ()=> onUp());
  }

  bindHold(leftBtn, ()=> holdingLeft=true, ()=> holdingLeft=false);
  bindHold(rightBtn, ()=> holdingRight=true, ()=> holdingRight=false);

  kickBtn.addEventListener("touchstart", (e)=>{ e.preventDefault(); doKick(); });
  batBtn.addEventListener("touchstart", (e)=>{ e.preventDefault(); doBat(); });

  kickBtn.addEventListener("mousedown", (e)=>{ e.preventDefault(); doKick(); });
  batBtn.addEventListener("mousedown", (e)=>{ e.preventDefault(); doBat(); });

  // KEYBOARD SUPPORT
  window.addEventListener("keydown", (e)=>{
    if(e.key === "a" || e.key === "A") holdingLeft = true;
    if(e.key === "d" || e.key === "D") holdingRight = true;

    if(e.key === "j" || e.key === "J") doKick();
    if(e.key === "k" || e.key === "K") doBat();
  });

  window.addEventListener("keyup", (e)=>{
    if(e.key === "a" || e.key === "A") holdingLeft = false;
    if(e.key === "d" || e.key === "D") holdingRight = false;
  });

  // START GAME
  startBtn.addEventListener("click", () => {
    startScreen.style.display = "none";
    setTimeout(() => {
      running = true;
      player.x = w/2 - player.w/2;
      spawnWave();
    }, 250);
  });

  // INIT
  resizeCanvas();
  requestAnimationFrame(loop);
</script>

</body>
</html>
