<!DOCTYPE html>
<html lang="cs">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>RAGE - danielsdili</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #0a0a0a;
      overflow: hidden;
      font-family: monospace;
      user-select: none;
    }

    canvas {
      display: block;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      background: #111;
    }

    #ui {
      position: fixed;
      top: 10px;
      left: 10px;
      color: white;
      z-index: 10;
      font-size: 14px;
      text-shadow: 2px 2px 0px black;
    }

    #ui .bar {
      width: 200px;
      height: 12px;
      border: 2px solid white;
      background: #222;
      margin-top: 4px;
    }

    #ui .fill {
      height: 100%;
      width: 0%;
      background: #ff2222;
    }

    #help {
      margin-top: 10px;
      color: #aaa;
      font-size: 12px;
      line-height: 1.4;
    }

    #overlay {
      position: fixed;
      inset: 0;
      background: black;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      z-index: 50;
      color: white;
      font-family: monospace;
      text-align: center;
    }

    #overlay h1 {
      font-size: 38px;
      margin: 0;
      color: #ff3333;
      text-shadow: 4px 4px 0px #000;
    }

    #overlay h2 {
      margin: 10px 0 0 0;
      font-size: 18px;
      color: #fff;
      opacity: 0.9;
    }

    #overlay p {
      margin-top: 20px;
      font-size: 14px;
      color: #aaa;
    }

    #overlay button {
      margin-top: 20px;
      padding: 10px 20px;
      font-family: monospace;
      font-size: 16px;
      border: 3px solid white;
      background: #111;
      color: white;
      cursor: pointer;
      box-shadow: 3px 3px 0px black;
    }

    #overlay button:hover {
      background: #ff2222;
    }

    #gameover {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.92);
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      z-index: 60;
      color: white;
      text-align: center;
      font-family: monospace;
    }

    #gameover h1 {
      font-size: 48px;
      margin: 0;
      color: #ff2222;
      text-shadow: 4px 4px 0px black;
    }

    #gameover p {
      margin-top: 15px;
      color: #ccc;
      font-size: 16px;
    }

    #gameover button {
      margin-top: 20px;
      padding: 10px 20px;
      font-family: monospace;
      font-size: 16px;
      border: 3px solid white;
      background: #111;
      color: white;
      cursor: pointer;
      box-shadow: 3px 3px 0px black;
    }

    #gameover button:hover {
      background: #22ff22;
      color: black;
    }
  </style>
</head>
<body>

<div id="ui">
  <div><b>RAGE</b> | Score: <span id="score">0</span></div>
  <div>Health: <span id="hp">100</span></div>
  <div class="bar"><div class="fill" id="hpFill"></div></div>

  <div style="margin-top:8px;">Chaos: <span id="chaos">0</span>%</div>
  <div class="bar"><div class="fill" id="chaosFill"></div></div>

  <div id="help">
    Ovl치d치n칤:<br>
    WASD = pohyb<br>
    SHIFT = sprint<br>
    SPACE = baseballka 코vih<br>
    E = kopnut칤 / 칰der<br>
    R = restart<br>
  </div>
</div>

<div id="overlay">
  <h2>danielsdili uv치d칤:</h2>
  <h1>RAGE</h1>
  <p>Pixel Riot Chaos Simulator</p>
  <button id="startBtn">START</button>
</div>

<div id="gameover">
  <h1>GAME OVER</h1>
  <p>Policie t캩 zpracovala 游때</p>
  <p>Sk칩re: <span id="finalScore">0</span></p>
  <button id="restartBtn">Zkusit znovu</button>
</div>

<canvas id="game"></canvas>

<script>
/* ============================================================
   RAGE - danielsdili
   Pixel Riot Chaos Simulator
   1 soubor HTML
   ============================================================ */

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

let W = window.innerWidth;
let H = window.innerHeight;

canvas.width = W;
canvas.height = H;

window.addEventListener("resize", () => {
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.width = W;
  canvas.height = H;
});

// UI
const scoreEl = document.getElementById("score");
const hpEl = document.getElementById("hp");
const hpFill = document.getElementById("hpFill");
const chaosEl = document.getElementById("chaos");
const chaosFill = document.getElementById("chaosFill");
const overlay = document.getElementById("overlay");
const gameoverScreen = document.getElementById("gameover");
const finalScoreEl = document.getElementById("finalScore");

const startBtn = document.getElementById("startBtn");
const restartBtn = document.getElementById("restartBtn");

// Pixel scale
const SCALE = 3;
const TILE = 16;

// Map size
const WORLD_W = 2400;
const WORLD_H = 2400;

// Camera
let camX = 0;
let camY = 0;

// Game state
let running = false;
let gameOver = false;

let score = 0;
let chaos = 0;

// Input
const keys = {};
window.addEventListener("keydown", (e) => {
  keys[e.key.toLowerCase()] = true;

  if(e.key.toLowerCase() === "r") resetGame();
});

window.addEventListener("keyup", (e) => {
  keys[e.key.toLowerCase()] = false;
});

// Utility
function clamp(v, min, max) {
  return Math.max(min, Math.min(max, v));
}

function dist(a, b) {
  return Math.hypot(a.x - b.x, a.y - b.y);
}

function rand(min, max) {
  return Math.random() * (max - min) + min;
}

function chance(p) {
  return Math.random() < p;
}

// Entities
const npcs = [];
const cops = [];
const objects = [];
const particles = [];

// Player
const player = {
  x: WORLD_W / 2,
  y: WORLD_H / 2,
  w: 14,
  h: 14,
  speed: 1.5,
  sprint: 2.5,
  hp: 100,
  maxHp: 100,
  dirX: 1,
  dirY: 0,
  swingTimer: 0,
  punchTimer: 0,
  invuln: 0
};

// Spawn objects
function spawnWorldObjects() {
  objects.length = 0;

  for(let i=0;i<180;i++){
    objects.push({
      type: "crate",
      x: rand(100, WORLD_W-100),
      y: rand(100, WORLD_H-100),
      w: 16,
      h: 16,
      hp: 3,
      broken: false
    });
  }

  for(let i=0;i<120;i++){
    objects.push({
      type: "car",
      x: rand(150, WORLD_W-150),
      y: rand(150, WORLD_H-150),
      w: 32,
      h: 18,
      hp: 8,
      broken: false
    });
  }

  for(let i=0;i<60;i++){
    objects.push({
      type: "shop",
      x: rand(150, WORLD_W-150),
      y: rand(150, WORLD_H-150),
      w: 36,
      h: 36,
      hp: 12,
      broken: false
    });
  }
}

// Spawn NPCs
function spawnNPCs() {
  npcs.length = 0;
  for(let i=0;i<80;i++){
    npcs.push(makeNPC());
  }
}

function makeNPC() {
  return {
    x: rand(100, WORLD_W-100),
    y: rand(100, WORLD_H-100),
    w: 12,
    h: 12,
    hp: 3,
    angry: chance(0.35),
    panic: false,
    vx: rand(-1,1),
    vy: rand(-1,1),
    cooldown: 0
  };
}

// Spawn cops
function spawnCops(count=5) {
  for(let i=0;i<count;i++){
    cops.push({
      x: rand(100, WORLD_W-100),
      y: rand(100, WORLD_H-100),
      w: 12,
      h: 12,
      hp: 6,
      speed: 1.3,
      attackCooldown: 0
    });
  }
}

// Collision check
function rectsOverlap(a,b){
  return (
    a.x < b.x + b.w &&
    a.x + a.w > b.x &&
    a.y < b.y + b.h &&
    a.y + a.h > b.y
  );
}

// Particles
function spawnParticles(x,y,amount,color){
  for(let i=0;i<amount;i++){
    particles.push({
      x, y,
      vx: rand(-1.5,1.5),
      vy: rand(-1.5,1.5),
      life: rand(15,30),
      color
    });
  }
}

// Damage helper
function dealDamage(target, dmg){
  target.hp -= dmg;
  if(target.hp <= 0){
    target.dead = true;
  }
}

// Player attacks
function doSwing() {
  if(player.swingTimer > 0) return;
  player.swingTimer = 18;

  // Swing arc zone
  const swingRange = 36;

  // direction from player
  const sx = player.dirX;
  const sy = player.dirY;

  // hitbox in front
  const hitbox = {
    x: player.x + sx * 18 - 16,
    y: player.y + sy * 18 - 16,
    w: 32,
    h: 32
  };

  // hit NPCs
  npcs.forEach(n => {
    if(n.dead) return;
    if(rectsOverlap(hitbox, n)){
      dealDamage(n, 2);
      spawnParticles(n.x+6, n.y+6, 6, "#ff4444");
      score += 10;
      chaos += 2;
      n.panic = true;
      n.vx = rand(-2,2);
      n.vy = rand(-2,2);
    }
  });

  // hit cops
  cops.forEach(c => {
    if(c.dead) return;
    if(rectsOverlap(hitbox, c)){
      dealDamage(c, 2);
      spawnParticles(c.x+6, c.y+6, 8, "#ff4444");
      score += 25;
      chaos += 4;
    }
  });

  // hit objects
  objects.forEach(o => {
    if(o.broken) return;
    if(rectsOverlap(hitbox, o)){
      o.hp -= 2;
      spawnParticles(o.x+o.w/2, o.y+o.h/2, 8, "#ffaa22");
      chaos += 3;
      score += 15;

      if(o.hp <= 0){
        o.broken = true;
        spawnParticles(o.x+o.w/2, o.y+o.h/2, 20, "#ffcc55");
        chaos += 6;
        score += 40;
      }
    }
  });
}

function doPunch() {
  if(player.punchTimer > 0) return;
  player.punchTimer = 12;

  const hitbox = {
    x: player.x + player.dirX * 12 - 10,
    y: player.y + player.dirY * 12 - 10,
    w: 20,
    h: 20
  };

  npcs.forEach(n => {
    if(n.dead) return;
    if(rectsOverlap(hitbox, n)){
      dealDamage(n, 1);
      spawnParticles(n.x+6, n.y+6, 4, "#ff4444");
      score += 5;
      chaos += 1;
      n.panic = true;
    }
  });

  cops.forEach(c => {
    if(c.dead) return;
    if(rectsOverlap(hitbox, c)){
      dealDamage(c, 1);
      spawnParticles(c.x+6, c.y+6, 4, "#ff4444");
      score += 10;
      chaos += 2;
    }
  });

  objects.forEach(o => {
    if(o.broken) return;
    if(rectsOverlap(hitbox, o)){
      o.hp -= 1;
      spawnParticles(o.x+o.w/2, o.y+o.h/2, 5, "#ffaa22");
      chaos += 1;
      score += 5;

      if(o.hp <= 0){
        o.broken = true;
        spawnParticles(o.x+o.w/2, o.y+o.h/2, 15, "#ffcc55");
        chaos += 5;
        score += 25;
      }
    }
  });
}

// Draw pixel blocks
function pxRect(x,y,w,h,color){
  ctx.fillStyle = color;
  ctx.fillRect(
    Math.floor(x),
    Math.floor(y),
    Math.floor(w),
    Math.floor(h)
  );
}

// Draw world
function drawWorld() {
  // background
  ctx.fillStyle = "#141414";
  ctx.fillRect(0,0,W,H);

  // grid roads
  for(let gx=0; gx<WORLD_W; gx+=64){
    const sx = gx - camX;
    if(sx < -64 || sx > W+64) continue;
    ctx.fillStyle = "#1c1c1c";
    ctx.fillRect(sx, -camY, 6, WORLD_H);
  }

  for(let gy=0; gy<WORLD_H; gy+=64){
    const sy = gy - camY;
    if(sy < -64 || sy > H+64) continue;
    ctx.fillStyle = "#1c1c1c";
    ctx.fillRect(-camX, sy, WORLD_W, 6);
  }

  // random neon trash dots
  for(let i=0;i<80;i++){
    const x = (i*37 % WORLD_W) - camX;
    const y = (i*91 % WORLD_H) - camY;
    if(x<0||y<0||x>W||y>H) continue;
    ctx.fillStyle = "#0f0";
    ctx.fillRect(x, y, 1, 1);
  }
}

// Draw objects
function drawObjects() {
  objects.forEach(o => {
    const sx = o.x - camX;
    const sy = o.y - camY;

    if(sx < -100 || sy < -100 || sx > W+100 || sy > H+100) return;

    if(o.type === "crate"){
      if(o.broken){
        pxRect(sx, sy, o.w, o.h, "#332200");
        pxRect(sx+2, sy+2, o.w-4, o.h-4, "#111");
      } else {
        pxRect(sx, sy, o.w, o.h, "#8b5a2b");
        pxRect(sx+3, sy+3, o.w-6, o.h-6, "#6a3e1c");
      }
    }

    if(o.type === "car"){
      if(o.broken){
        pxRect(sx, sy, o.w, o.h, "#222");
        pxRect(sx+4, sy+4, o.w-8, o.h-8, "#111");
      } else {
        pxRect(sx, sy, o.w, o.h, "#cc0000");
        pxRect(sx+4, sy+4, o.w-8, o.h-8, "#770000");
        pxRect(sx+6, sy+2, 6, 4, "#99ccff");
        pxRect(sx+18, sy+2, 6, 4, "#99ccff");
      }
    }

    if(o.type === "shop"){
      if(o.broken){
        pxRect(sx, sy, o.w, o.h, "#222");
        pxRect(sx+4, sy+4, o.w-8, o.h-8, "#111");
      } else {
        pxRect(sx, sy, o.w, o.h, "#4444aa");
        pxRect(sx+4, sy+4, o.w-8, o.h-8, "#222266");
        pxRect(sx+10, sy+10, 16, 10, "#aaffff");
      }
    }
  });
}

// Draw NPCs
function drawNPCs() {
  npcs.forEach(n => {
    if(n.dead) return;
    const sx = n.x - camX;
    const sy = n.y - camY;
    if(sx < -50 || sy < -50 || sx > W+50 || sy > H+50) return;

    let body = n.angry ? "#ffcc00" : "#aaaaaa";
    if(n.panic) body = "#ff66ff";

    pxRect(sx, sy, n.w, n.h, body);
    pxRect(sx+3, sy+3, 2, 2, "#000");
    pxRect(sx+7, sy+3, 2, 2, "#000");
  });
}

// Draw cops
function drawCops() {
  cops.forEach(c => {
    if(c.dead) return;
    const sx = c.x - camX;
    const sy = c.y - camY;
    if(sx < -50 || sy < -50 || sx > W+50 || sy > H+50) return;

    pxRect(sx, sy, c.w, c.h, "#2255ff");
    pxRect(sx+2, sy+2, c.w-4, c.h-4, "#112288");
    pxRect(sx+4, sy+3, 2, 2, "#fff");
    pxRect(sx+7, sy+3, 2, 2, "#fff");
  });
}

// Draw player
function drawPlayer() {
  const sx = player.x - camX;
  const sy = player.y - camY;

  // body
  pxRect(sx, sy, player.w, player.h, "#00ff88");
  pxRect(sx+2, sy+2, player.w-4, player.h-4, "#007744");

  // eyes
  pxRect(sx+4, sy+4, 2, 2, "#000");
  pxRect(sx+8, sy+4, 2, 2, "#000");

  // baseball bat when swinging
  if(player.swingTimer > 0){
    const bx = sx + player.dirX * 14;
    const by = sy + player.dirY * 14;
    pxRect(bx, by, 12, 3, "#aa7744");
  }
}

// Particles draw
function drawParticles() {
  particles.forEach(p => {
    const sx = p.x - camX;
    const sy = p.y - camY;
    ctx.fillStyle = p.color;
    ctx.fillRect(sx, sy, 2, 2);
  });
}

// Update player
function updatePlayer() {
  let spd = player.speed;
  if(keys["shift"]) spd = player.sprint;

  let dx = 0;
  let dy = 0;

  if(keys["w"]) dy -= spd;
  if(keys["s"]) dy += spd;
  if(keys["a"]) dx -= spd;
  if(keys["d"]) dx += spd;

  if(dx !== 0 || dy !== 0){
    const len = Math.hypot(dx,dy);
    dx /= len;
    dy /= len;

    player.dirX = dx;
    player.dirY = dy;

    player.x += dx * spd * 2;
    player.y += dy * spd * 2;
  }

  player.x = clamp(player.x, 10, WORLD_W-10);
  player.y = clamp(player.y, 10, WORLD_H-10);

  if(keys[" "]){
    doSwing();
  }

  if(keys["e"]){
    doPunch();
  }

  if(player.swingTimer > 0) player.swingTimer--;
  if(player.punchTimer > 0) player.punchTimer--;
  if(player.invuln > 0) player.invuln--;

  // camera follow
  camX = player.x - W/2;
  camY = player.y - H/2;

  camX = clamp(camX, 0, WORLD_W - W);
  camY = clamp(camY, 0, WORLD_H - H);
}

// Update NPC AI
function updateNPCs() {
  npcs.forEach(n => {
    if(n.dead) return;

    if(n.cooldown > 0) n.cooldown--;

    // random movement
    if(chance(0.02)){
      n.vx = rand(-1.2,1.2);
      n.vy = rand(-1.2,1.2);
    }

    // angry NPC might attack player
    if(n.angry && dist(n, player) < 40 && n.cooldown <= 0){
      n.vx = (player.x - n.x) * 0.03;
      n.vy = (player.y - n.y) * 0.03;
      if(dist(n, player) < 18){
        if(player.invuln <= 0){
          player.hp -= 4;
          player.invuln = 20;
          spawnParticles(player.x, player.y, 10, "#ff4444");
        }
        n.cooldown = 40;
      }
    }

    // panic = run away
    if(n.panic){
      n.vx += rand(-0.4,0.4);
      n.vy += rand(-0.4,0.4);
      n.vx = clamp(n.vx, -2.2, 2.2);
      n.vy = clamp(n.vy, -2.2, 2.2);

      if(chance(0.01)){
        n.panic = false;
      }
    }

    n.x += n.vx;
    n.y += n.vy;

    n.x = clamp(n.x, 10, WORLD_W-10);
    n.y = clamp(n.y, 10, WORLD_H-10);
  });

  // remove dead
  for(let i=npcs.length-1;i>=0;i--){
    if(npcs[i].dead){
      npcs.splice(i,1);
      chaos += 2;
      score += 20;
    }
  }

  // respawn some
  if(npcs.length < 70 && chance(0.03)){
    npcs.push(makeNPC());
  }
}

// Update cops AI
function updateCops() {
  cops.forEach(c => {
    if(c.dead) return;

    if(c.attackCooldown > 0) c.attackCooldown--;

    const d = dist(c, player);

    // chase
    if(d < 300){
      const dx = (player.x - c.x);
      const dy = (player.y - c.y);
      const len = Math.hypot(dx,dy) || 1;

      c.x += (dx/len) * c.speed;
      c.y += (dy/len) * c.speed;
    } else {
      // wander
      if(chance(0.02)){
        c.x += rand(-20,20);
        c.y += rand(-20,20);
      }
    }

    // attack if close
    if(d < 18 && c.attackCooldown <= 0){
      if(player.invuln <= 0){
        player.hp -= 8;
        player.invuln = 25;
        spawnParticles(player.x, player.y, 14, "#ff2222");
      }
      c.attackCooldown = 50;
    }

    c.x = clamp(c.x, 10, WORLD_W-10);
    c.y = clamp(c.y, 10, WORLD_H-10);
  });

  // remove dead cops
  for(let i=cops.length-1;i>=0;i--){
    if(cops[i].dead){
      cops.splice(i,1);
      chaos += 6;
      score += 100;
    }
  }
}

// Chaos system
function updateChaos() {
  chaos = clamp(chaos, 0, 100);

  // police reinforcements
  if(chaos > 20 && cops.length < 8 && chance(0.02)) spawnCops(1);
  if(chaos > 40 && cops.length < 12 && chance(0.03)) spawnCops(1);
  if(chaos > 60 && cops.length < 18 && chance(0.04)) spawnCops(2);
  if(chaos > 80 && cops.length < 25 && chance(0.05)) spawnCops(3);

  // chaos slowly decreases
  chaos -= 0.02;
  if(chaos < 0) chaos = 0;
}

// Update particles
function updateParticles() {
  for(let i=particles.length-1;i>=0;i--){
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.life--;

    if(p.life <= 0){
      particles.splice(i,1);
    }
  }
}

// UI update
function updateUI() {
  scoreEl.textContent = score;
  hpEl.textContent = Math.max(0, Math.floor(player.hp));

  const hpPct = (player.hp / player.maxHp) * 100;
  hpFill.style.width = hpPct + "%";

  chaosEl.textContent = Math.floor(chaos);
  chaosFill.style.width = chaos + "%";
}

// Game over
function checkGameOver() {
  if(player.hp <= 0){
    gameOver = true;
    running = false;
    finalScoreEl.textContent = score;
    gameoverScreen.style.display = "flex";
  }
}

// Reset
function resetGame() {
  score = 0;
  chaos = 0;
  player.hp = 100;
  player.x = WORLD_W/2;
  player.y = WORLD_H/2;
  player.swingTimer = 0;
  player.punchTimer = 0;
  player.invuln = 0;

  npcs.length = 0;
  cops.length = 0;
  particles.length = 0;

  spawnWorldObjects();
  spawnNPCs();
  spawnCops(4);

  gameOver = false;
  running = true;
  gameoverScreen.style.display = "none";
}

// Main loop
function loop() {
  if(running){
    updatePlayer();
    updateNPCs();
    updateCops();
    updateChaos();
    updateParticles();
    updateUI();
    checkGameOver();
  }

  // Draw
  drawWorld();
  drawObjects();
  drawNPCs();
  drawCops();
  drawPlayer();
  drawParticles();

  requestAnimationFrame(loop);
}

// Start button
startBtn.addEventListener("click", () => {
  overlay.style.display = "none";
  resetGame();
});

// Restart button
restartBtn.addEventListener("click", () => {
  resetGame();
});

// Start loop always
loop();
</script>

</body>
</html>
